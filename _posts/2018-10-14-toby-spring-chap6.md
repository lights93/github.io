---
layout: post
title: "토비의 스프링 6장"
date: 2018-10-14
excerpt: "AOP"
tags: [tobySpring]
comments: true
---

# 6. AOP

## 6.1 사용자 레벨 관리 기능 추가

* 6.1.1 메소드 분리
	* 트랜잭션 경계설정의 코드와 비즈니스 로직 코드 간에 서로 주고받는 정보가 없기 때문에 분리 가능
* 6.1.2 DI를 이용한 클래스의 분리
	* DI 적용을 이용한 트랜잭션 분리
		* 한 번에 두 개의 UserService 인터페이스 구현 클래스 이용(UserServiceImpl, UserServiceTx)
	* UserService 인터페이스 도입
	```
	public interface UserService {
		void add(User user);
		void upgradeLevels();
	}
	```
		* UserService 인터페이스의 구현 클래스인 UserServiceImpl은 기존 UserService 클래스에서 트랜잭션과 관련된 코드만 제거하고 나머지는 유지한다.
	* 분리된 트랜잭션 기능
		* UserServiceTx는 UserService를 구현한 다른 오브젝트를 DI 받는다.
		* DI 받은 UserService 오브젝트에 모든 기능을 위임한다.
		* 그 후 트랜잭션을 적용한다.
	* 트랜잭션 적용을 위한 DI 설정
	* 트랜잭션 분리에 따른 테스트 수정
		* 같은 타입의 빈이 두 개라면 필드 이름(아이디)를 이용해 빈을 찾는다.
		* 목 오브젝트를 이용해 수동 DI를 적용하는 테스트라면 어떤 클래스의 오브젝트인지 분명하게 선언
	* 트랜잭션 경계설정 코드 분리의 장점
		* 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경쓰지 않아도 된다.
		* 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다.

## 6.2 고립된 단위 테스트
* 6.2.1 복잡한 의존관계 속의 테스트
	* UserService를 테스트하는 것처럼 보이지만 사실은 그 뒤에 존재하는 훨씬 더 많은 오브젝트와 환경, 서비스, 서버, 네트워크까지 함께 테스트함
* 6.2.2 테스트 대상 오브젝트 고립시키기
	테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다.
	* 테스트를 위한 UserServiceImpl 고립
	* 고립된 단위 테스트 활용
		1. 테스트 실행 중에 UserDao를 통해 가져올 테스트용 정보를 DB에 넣는다.
		2. 메일 발송 여부를 확인하기 위해 MailSender 목 오브젝트를 DI 해준다.
		3. 실제 테스트 대상인 userService의 메소드를 실행한다.
		4. 결과각 DB에 반영됐는지 확인하기 위해서 UserDao를 이용해 DB에서 데이터를 가져와 결과를 확인한다.
		5. 목 오브젝트를 통해 UserService에 의한 메일 발송이 있었는지를 확인하면 된다.
	* UserDao 목 오브젝트
		* UserDao와 DB까지 직접 의존하고 있는 첫 번째와 네 번째의 테스트 방식에 목 오브젝트 적용
		* getAll()에 대해서는 스텁으로서, update()에 대해서는 목 오브젝트로서 동작하는 UserDao의 테스트 대역 필요 -> MockUserDao
		* 인터페이스를 구현하므로 사용하지 않는 메소드가 있다. 이 메소드에서는 아무 것도 안 하는 것 보다 UnsupportedOperationException을 던지게 하여 지원하지 않는 기능이라는 예외가 발생하도록 만드는 것이 좋다.
		* 기존에는 @AutoWired를 통해 UserService 타입의 빈을 가져왔지만, MockUserDao를 도입하여 고립됐기 때문에 빈을 가져올 필요가 없다.
	* 테스트 수행 성능의 향상
		* 고립된 테스트를 하면 테스트가 다른 의존 대상에 영향을 받을 경우를 대비해 복잡하게 준비할 필요가 없을 뿐만 아니라, 테스트 수행 성능도 향상된다.

## 6.2.3 단위 테스트와 통합 테스트

* 단위 테스트: 테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트하는 것
* 통합 테스트: 두 개 이상의, 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트
* 단위 테스트와 통합 테스트 중에서 어떤 방법을 쓸지에 대한 가이드라인
	* 항상 단위 테스트를 먼저 고려한다.
	* 하나의 클래스나 성격과 목적이 같은 긴밀한 클래스 몇 개를 모아서 외부와의 의존관계를 모두 차단하고 필요에 따라 스텁이나 목 오브젝트 등의 테스트 대역을 이용하도록 테스트를 만든다.
	* 외부 리소스를 사용해야만 가능한 테스트는 통합 테스트로 만든다.
	* DAO처럼 DB를 통해 로직을 수행하는 코드는 단위 테스트로 만들기 어렵다.
	* DAO를 테스트를 통해 충분히 검증해두면, DAO를 이용하는 코드는 DAO 역할을 스텁이나 목 오브젝트로 대체해서 테스트할 수 있다.
	* 여러 개의 단위가 의존관계를 가지고 동작할 때를 위한 통합 테스트는 필요하다. 다만, 단위 테스트를 충분히 거쳤다면 통합 테스트의 부담은 상대적으로 줄어든다.
	* 단위 테스트를 만들기가 너무 복잡하다고 판단되는 코드는 처음부터 통합 테스트를 고려해본다.
	* 스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합 테스트다. 가능하면 스프링의 지원 없이 직접 코드 레벨의 DI를 사용하면서 단위 테스트를 하는 게 좋다.
* 테스트는 코드가 작성되고 빠르게 진행되는 편이 좋다.
* 코드르 작성하면서 테스트는 어떻게 만들 수 있을까를 생각해보는 것은 좋은 습관이다.

## 6.2.4 목 프레임워크

* Mockito 프레임워크
	* 목 프레임워크의 특징은 목 클래스를 일일이 준비할 필요가 없다는 점이다.
	* Mockito 목 오브젝트 사용 단계
		1. 인터페이스를 이용해 목 오브젝트를 만든다.
		2. 목 오브젝트가 리턴할 값이 있으면 이를 지정해준다. 예외를 강제로 던지게 만들 수도 있다.
		3. 테스트 대상 오브젝트에 DI 해서 목 오브젝트가 테스트 중에 사용되도록 만든다.
		4. 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됐는지, 어떤 값을 가지고 몇 번 호출됐는지를 검증한다.

## 6.3 다이내믹 프록시와 팩토리 빈
