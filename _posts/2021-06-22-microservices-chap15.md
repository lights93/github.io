---
title: "쿠버네티스 소개"
date: 2021-06-22
excerpt: "마이크로서비스"
categories:
  - microservice
tags:
  - microservice
---

# 15. 쿠버네티스 소개

## 쿠버네티스 개념 소개

쿠버네티스는 컨테이너를 실행하는 서버 클러스터를 하나의 커다란 논리 서버로 만드는 컨테이너 오케스트레이션

쿠버네티스 클러스터의 주요 목적 중 하나는 컨테이너를 배포 및 실행하면서 불루/그린 배포나 카나리아 배포 등의 기술을 사용해 무중단 롤링 업그레이드를 지원하는 것

쿠버네티스는 하나 혹은 다수의 컨테이너가 배치된 **포드(pod)**를 클러스터의 가용 노드에 스케줄링 가능

쿠버네티스는 실행 중인 컨테이너 상태를 모니터링할 수 있도록 컨테이너가 **라이브니스 프로브(liveness probe)**를 구현한다고 가정

수평 오토스케일러를 사용해 자동이나 수동으로 컨테이너를 스케일링 가능

메모리 및 CPU와 같은 클러스터의 가용 하드웨어 자원을 최적화하려먼 **할당량(quota)**을 사용해 컨테이너를 구성해 컨테이너에 필요하 자원 양을 지정

컨테이너 그룹이 소비할 수 있는 자원 양에 대한 제한은 **네임스페이스(namespace)** 수준에서 지정   



쿠버네티스의 다른 주요 목적은 실행 중인 포드와 컨테이너를 위한 서비스 검색을 제공하는 것

쿠버네티스의 서비스 객체를 정의하면 요청을 가용 포드로 로드 밸런싱하고 서비스를 검색할 수 있다

컨테이너가 **레디니스 프로브(readiness probe)**를 구현하면 들어오는 요청을 수락할 준비가 됐는지 쿠버네티스가 안다  



내부적으로 클러스터는 각 포드에 IP 주소를 할당하고 포드를 실행하는 노드와 관계 없이 다른 포드에 접근할 수 있게 하는 하나의 플랫IP 네트워크를 제공

여러 팀이 하나의 쿠버네티스 클러스터에서 안전하게 작업할 수 있도록 **역할 기반 접근 제어(RBAC, Role-Based Access Control)**를 적용 가능



## 쿠버네티스 API 객체 소개

- 노드(node): 클러스터에 속한 가상 혹은 물리 서버
- 포드(pod): 쿠버네티스에 배포할 수 있는 컴포넌트의 최소 단위, 하나 혹은 여러 개의 컨테이너를 포함
- 디플로이먼트(deployment): 포드를 배포하고 업그레이드, 포드 생성과 모니터링을 레플리카 셋이 담당하도록 위임
- 레플리카 셋(replica set): 지정한 수의 포드가 항상 실행되게 함 포드가 삭제되면 레플리카 셋이 대체할 포드를 실행
- 서비스(service): 하나 혹은 여러 개의 포드에 연결하고자 사용하는 안정적인 네트워크 엔드포인트, 서비스에는 쿠버네티스 클러스터의 내부 네트워크 IP 주소와 DNS 이름이 할당됨
- 인그레스(ingress): 쿠버네티스 클러스터의 서비스에 대한 HTTP 기반의 외부 접근을 관리
- 네임스페이스(namespace): 쿠버네티스 클러스터의 리소스를 모으고 특정 수준으로 격리하고자 사용
- 컨피그 맵(config map): 컨테이너에서 사용하는 구성을 저장할 떼 사용
- 시크릿(secret): 자격 증명 등의 컨테이너에서 사용하는 민감한 정보를 저장할 때 사용
- DaemonSet: 클러스터 노드 집합의 각 노드마다 하나의 포드가 실행되게 함

## 쿠버네티스 런타임 컴포넌트 소개

쿠버네티스 클러스터는 마스터 노드와 워커 노드로 구성됨.

마스터 노드는 클러스터를 관리하며, 워커 노드는 실제 워크로드를 실행

- 다음은 컨트롤 플레인을 구성하는, 마스터 노드에서 실행되는 컴포넌트
  - API 서버(api-server): 컨트롤 플레인의 진입점
  - etcd: 가용성이 높은 키/값 저장소로 클러스터의 모든 데이터를 저장하는 데이터베이스로 사용
  - 컨트롤러 매니저: etcd 데이터베이스에 정의된객체의 현재 상태와 원하는 생타를 비교해 지속적으로 평가하는 여러 컨트롤러를 포함
  - 원하는 상태나 현재 상태가 변경될 때마다 해당 상태 유형을 담당하는 컨트롤러가 원하는 상태와 현재 상태를 맞추는 작업을 수행
  - 스케줄러: 새로 생성된 컨테이너를 사용 가능한 메모리, CPU 등을 고려해 적절한 노드에 할당
- 데이터 플레인을 구성하는, 전체 노드에서 실행되는 컴포넌트
  - kubelet: 컨테이너롤 실행되지 않고 노드의 운영체제에서 직접 실행되는 노드 에이전트
  - kube-proxy: 쿠버네티스의 서비스 개념을 구현하는 네트워크 프록시
  - 컨테이너 런타임: 노드에서 컨테이너를 실행하는 소프트웨어
  - 쿠버네티스 DNS: 클러스터 내부 네트워크에서 사용하는 DNS 서버

## 미니큐브를 사용해 쿠버네티스 클러스터 생성

### 미니큐브 프로필 사용

여러 개의 쿠버네티스 클러스터를 로컬에서 실행하고자 미니큐브는 프로필이라는 개념을 제공

```minikube profile my-profile``` my-profile 프로필을 현재 프로필로 설정

```minikube config get profile``` 현재 프로필 확인

### 쿠버네티스의 CLI 도구인 kubectl 사용

- kubectl get: 지정한 API 객체의 정보를 보여줌
- kubectl describe: 지정한 API 객체의 자세한 정보 출력
- kubectl logs: 컨테이너의 로그 출력

### kubectl 콘텍스트 사용

다음과 같은 요소로 구성

- 쿠버네티스 클러스터
- 사용자 자격 증명
- 기본 네임스페이스

```kubectl config get-contexts``` 사용할 수 있는 콘텍스트  확인

```kubectl config set-context $(kubectl config current-context) --namespace my-namespace``` 현재 콘텍스트의 기본 네임스페이스 변경

### 쿠버네티스 클러스터 생성

## 샘플 디플로이먼트 생성

```yaml
apiVersion: apps/v1
kind: Deployment
metadata: # 디플로이먼트 객체 설명
  name: nginx-deploy # 객체의 이름 설정
spec:
  replicas: 1 # 포드 하나만 실행
  selector: # 디플로이먼트가 대상 포드를 찾는 방법
    matchLabels:
      app: nginx-app # app 레이블의 값이 nginx-app인 포드를 찾도록 지정
  template: # 포드 생성 방법
    metadata:
      labels:
        app: nginx-app # 셀렉터
    spec: # 포드에서 생성할 컨테이너에 대한 세부 사항을 지정
      containers:
      - name: nginx-container
        image: nginx:latest
        ports:
        - containerPort: 80

```

```yaml
apiVersion: v1
kind: Service
metadata: # 서비스객체 설명
  name: nginx-service
spec: # 서비스 객체 상태 지정
  type: NodePort # 외부에서 클러스터 노드에 접근하기 위한 전용 포트 지정 가능
  selector: # 서비스가 대상 포드를 찾도록 지정
    app: nginx-app
  ports:
    - targetPort: 80 # 요청이 전달될 포드의 포트 지정
      port: 80 # 클러스터 내부에선 80포트를 사용해 서비스에 접근할 수 있다고 지정
      nodePort: 30080 # 외부에서 서비스에 접근할 떄 사용할 클러스터 노드의 포트(30000 - 32767 사이에서 지정)
```

클러스터 내부에선 어떻게 접속?

```bash
kubectl run -i --rm --restart=Never curl-client --image=tutum/curl:alpine --command -- curl -s 'http://nginx-service:80'
```

## 쿠버네티스 클러스터 관리

생략

## 참고

- 마이크로서비스(http://www.acornpub.co.kr/book/microservices-spring)